#include "definitions_generator.hpp"
#include <tsuki/tsuki.hpp>
#include <tsuki/lua_bindings.hpp>
#include <spdlog/spdlog.h>
#include <fstream>
#include <sstream>

namespace tsuki::cli {

std::string DefinitionsGenerator::generate() {
    introspectLuaState();
    return formatDefinitions();
}

bool DefinitionsGenerator::saveToFile(const std::string& path) {
    try {
        std::string content = generate();
        std::ofstream file(path);
        if (!file) {
            spdlog::error("Failed to open file for writing: {}", path);
            return false;
        }
        file << content;
        file.close();
        return true;
    } catch (const std::exception& e) {
        spdlog::error("Failed to save definitions: {}", e.what());
        return false;
    }
}

void DefinitionsGenerator::introspectLuaState() {
    try {
        // Use the engine singleton to introspect
        tsuki::Engine& engine = tsuki::Engine::getInstance();
        if (!engine.init()) {
            spdlog::error("Failed to initialize engine for introspection");
            return;
        }

        sol::state& lua = engine.getLuaEngine().getLuaState();

        // Register all bindings
        tsuki::LuaBindings::registerAll(lua, &engine);

        // Get the tsuki table
        sol::optional<sol::table> tsuki_table = lua["tsuki"];
        if (!tsuki_table) {
            spdlog::error("tsuki table not found in Lua state");
            return;
        }

        lua_State* L = lua.lua_state();

        // Automatically discover all modules in the tsuki table
        tsuki_table->for_each([&](sol::object key, sol::object value) {
            if (!key.is<std::string>()) return;

            std::string module_name = key.as<std::string>();

            // Skip lifecycle callbacks and helper functions
            if (module_name == "load" || module_name == "update" ||
                module_name == "draw" || module_name == "print") {
                return;
            }

            // Capitalize first letter for class name
            std::string class_name = module_name;
            if (!class_name.empty()) {
                class_name[0] = std::toupper(class_name[0]);
            }

            ClassInfo class_info;
            class_info.name = class_name;

            // Handle usertypes (graphics, keyboard, mouse, window)
            if (value.get_type() == sol::type::userdata) {
                value.push(L);

                if (lua_getmetatable(L, -1)) {
                    lua_pushnil(L);  // First key

                    while (lua_next(L, -2)) {
                        if (lua_type(L, -2) == LUA_TSTRING) {
                            const char* method_key = lua_tostring(L, -2);
                            std::string method_name(method_key);

                            // Skip internal metamethods and constructors
                            if (method_name.find("__") != 0 && method_name != "new" &&
                                lua_type(L, -1) == LUA_TFUNCTION) {
                                MethodInfo method;
                                method.name = method_name;
                                class_info.methods.push_back(method);
                            }
                        }
                        lua_pop(L, 1);
                    }
                    lua_pop(L, 1);  // Pop metatable
                }
                lua_pop(L, 1);  // Pop userdata

                if (!class_info.methods.empty()) {
                    classes_[class_name] = class_info;
                }
            }
            // Handle tables (debug)
            else if (value.get_type() == sol::type::table) {
                sol::table module_table = value.as<sol::table>();

                module_table.for_each([&](sol::object tbl_key, sol::object tbl_value) {
                    if (tbl_key.is<std::string>() && tbl_value.get_type() == sol::type::function) {
                        MethodInfo method;
                        method.name = tbl_key.as<std::string>();
                        class_info.methods.push_back(method);
                    }
                });

                if (!class_info.methods.empty()) {
                    classes_[class_name] = class_info;
                }
            }
        });

    } catch (const std::exception& e) {
        spdlog::error("Error during introspection: {}", e.what());
    }
}


std::string DefinitionsGenerator::formatDefinitions() const {
    std::ostringstream out;

    out << "-- Tsuki Lua API Definitions\n";
    out << "-- Auto-generated by introspecting Lua state\n";
    out << "-- Place this file in your project root and add it to .luarc.json workspace.library\n\n";
    out << "---@meta tsuki\n\n";

    // Generate class definitions (sorted alphabetically for consistency)
    std::vector<std::string> sorted_classes;
    for (const auto& [class_name, _] : classes_) {
        sorted_classes.push_back(class_name);
    }
    std::sort(sorted_classes.begin(), sorted_classes.end());

    for (const auto& class_name : sorted_classes) {
        const auto& class_info = classes_.at(class_name);

        out << "---@class " << class_name << "\n";

        for (const auto& method : class_info.methods) {
            out << "---@field " << method.name << " fun(self: " << class_name << ", ...): any\n";
        }

        out << "local " << class_name << " = {}\n\n";
    }

    // Generate main tsuki table dynamically
    out << "---@class tsuki\n";

    // Add discovered modules
    for (const auto& class_name : sorted_classes) {
        std::string module_name = class_name;
        if (!module_name.empty()) {
            module_name[0] = std::tolower(module_name[0]);
        }
        out << "---@field " << module_name << " " << class_name << "\n";
    }

    // Add lifecycle callbacks
    out << "---@field print fun(value: any)\n";
    out << "---@field load fun()?\n";
    out << "---@field update fun(dt: number)?\n";
    out << "---@field draw fun()?\n";
    out << "tsuki = {}\n";

    return out.str();
}

} // namespace tsuki::cli